/**
 * Milestone Workflow Orchestrator
 *
 * Ties together all milestone creation modules:
 * - Planning documents (planning-docs.js)
 * - Requirements gathering (requirements.js)
 * - State management (state.js)
 * - Git operations (git/branches.js, git/git.js)
 * - GitHub posting (lib/github.js)
 * - Summary generation (summarizer.js)
 */

import * as core from "@actions/core";
import * as github from "@actions/github";
import { postComment, getWorkflowRunUrl } from "../lib/github.js";
import { formatErrorComment } from "../errors/formatter.js";
import { createMilestoneBranch, branchExists } from "../git/branches.js";
import { runGitCommand, configureGitIdentity } from "../git/git.js";
import { loadState, saveState, createInitialState, isRequirementsComplete, updateRequirementsAnswer, initializePendingQuestions, updateWorkflowRun, markRequirementsComplete } from "./state.js";
import { createPlanningDocs } from "./planning-docs.js";
import { getNewComments, parseUserAnswers, formatRequirementsQuestions, parseAnswersFromResponse, DEFAULT_QUESTIONS } from "./requirements.js";
import { generateMilestoneSummary } from "./summarizer.js";

/**
 * Parse milestone number from command arguments
 * Supports formats:
 * - "5" (just the number)
 * - "--milestone 5"
 * - "--milestone=5"
 *
 * @param {string} commandArgs - Command arguments string
 * @returns {number} Parsed milestone number
 * @throws {Error} If milestone number cannot be parsed
 */
export function parseMilestoneNumber(commandArgs) {
  if (!commandArgs) {
    throw new Error("Milestone number is required");
  }

  // Try to extract from --milestone flag
  const milestoneFlagMatch = commandArgs.match(/--milestone[=\s]+(\d+)/);
  if (milestoneFlagMatch) {
    return parseInt(milestoneFlagMatch[1], 10);
  }

  // Try to extract from -m flag
  const mFlagMatch = commandArgs.match(/-m[=\s]+(\d+)/);
  if (mFlagMatch) {
    return parseInt(mFlagMatch[1], 10);
  }

  // Try to extract standalone number at the end
  const standaloneMatch = commandArgs.match(/(\d+)$/);
  if (standaloneMatch) {
    return parseInt(standaloneMatch[1], 10);
  }

  throw new Error("Could not parse milestone number from arguments. Use '--milestone N' or provide the number directly.");
}

/**
 * Commit planning documents to the milestone branch
 *
 * @param {number} milestoneNumber - Milestone number
 * @param {Array<{path: string, purpose: string}>} files - Files to commit
 * @returns {Promise<void>}
 */
async function commitPlanningDocs(milestoneNumber, files) {
  // Configure git identity for commits
  await configureGitIdentity(
    "github-actions[bot]",
    "41898282+github-actions[bot]@users.noreply.github.com"
  );

  // Create milestone branch if it doesn't exist
  const branchName = `gsd/${milestoneNumber}`;
  const exists = await branchExists(branchName);

  if (!exists) {
    await createMilestoneBranch(milestoneNumber);
  } else {
    // Switch to existing branch
    await runGitCommand(`git switch ${branchName}`);
    core.info(`Switched to existing branch: ${branchName}`);
  }

  // Stage all planning files
  for (const file of files) {
    await runGitCommand(`git add "${file.path}"`);
    core.info(`Staged ${file.path}`);
  }

  // Create commit with planning docs
  const fileNames = files.map(f => f.path.split('/').pop()).join(', ');
  await runGitCommand(`git commit -m "docs(m${milestoneNumber}): Create initial planning documents

- ${fileNames}

Generated by GSD Bot"`);

  core.info(`Committed ${files.length} planning files to ${branchName}`);
}

/**
 * Execute the complete milestone creation workflow
 *
 * This orchestrator handles the full lifecycle:
 * 1. Load or create state
 * 2. Fetch and parse new user comments
 * 3. Update requirements with new answers
 * 4. If incomplete: post pending questions, save state, return
 * 5. If complete: create planning docs, commit to branch, post summary
 *
 * @param {object} context - GitHub action context
 * @param {string} context.owner - Repository owner
 * @param {string} context.repo - Repository name
 * @param {number} context.issueNumber - Issue number for comments
 * @param {string} commandArgs - Command arguments string
 * @returns {Promise<object>} Workflow result
 * @throws {Error} If workflow cannot complete
 */
export async function executeMilestoneWorkflow(context, commandArgs) {
  const { owner, repo, issueNumber } = context;
  const workflowUrl = getWorkflowRunUrl();

  core.info(`Starting milestone workflow for ${owner}/${repo}#${issueNumber}`);

  try {
    // Step 1: Parse milestone number from arguments
    const milestoneNumber = parseMilestoneNumber(commandArgs);
    core.info(`Parsed milestone number: ${milestoneNumber}`);

    // Step 2: Load existing state or create initial state
    let state = await loadState(owner, repo, milestoneNumber);

    // Step 3: Update workflow metadata (run count, last run time)
    updateWorkflowRun(state);

    // Step 4: Get new comments since last processed
    const lastProcessedId = state.workflow?.lastCommentId || 0;
    const newComments = await getNewComments(owner, repo, issueNumber, lastProcessedId);

    // Step 5: Parse user answers from new comments
    const userAnswers = parseUserAnswers(newComments);

    // Step 6: Merge new answers into state
    if (userAnswers.length > 0) {
      for (const answer of userAnswers) {
        const parsedAnswers = parseAnswersFromResponse(answer.body, DEFAULT_QUESTIONS, state.requirements.answered);

        // Update state with each parsed answer
        for (const [questionId, answerText] of Object.entries(parsedAnswers)) {
          updateRequirementsAnswer(state, questionId, answerText, answer.commentId);
        }
      }
    }

    // Initialize pending questions if not already done
    if (!state.requirements.pending || state.requirements.pending.length === 0) {
      initializePendingQuestions(state, DEFAULT_QUESTIONS);
    }

    // Step 7: Check if requirements gathering is complete
    const requirementsComplete = isRequirementsComplete(state, DEFAULT_QUESTIONS);

    if (!requirementsComplete) {
      // Requirements not yet complete - post pending questions
      core.info("Requirements not complete, posting pending questions");

      const questionsMarkdown = formatRequirementsQuestions(
        DEFAULT_QUESTIONS,
        state.requirements.answered
      );

      await postComment(owner, repo, issueNumber, questionsMarkdown);

      // Save state for next run
      await saveState(owner, repo, milestoneNumber, state);

      return {
        complete: false,
        phase: "requirements-gathering",
        milestone: milestoneNumber,
        answered: Object.keys(state.requirements.answered),
        pending: state.requirements.pending,
        message: "Waiting for user answers to complete requirements gathering"
      };
    }

    // Step 8: Requirements complete - transition to planning phase
    core.info("All required questions answered, creating planning documents");

    // Mark requirements as complete
    markRequirementsComplete(state);
    state.status = "planning";

    // Build milestone data for planning documents
    const milestoneData = {
      owner,
      repo,
      milestoneNumber,
      title: state.requirements.answered.scope ? `Milestone ${milestoneNumber}: ${state.requirements.answered.scope.substring(0, 50)}` : `Milestone ${milestoneNumber}`,
      goal: state.requirements.answered.scope || "To be defined",
      scope: state.requirements.answered.constraints || "To be defined",
      features: state.requirements.answered.features ? state.requirements.answered.features.split('\n').filter(f => f.trim()) : [],
      requirements: {
        complete: true,
        answered: Object.keys(state.requirements.answered),
        pending: []
      },
      phases: [],
      totalPhases: 6,
      status: "planning",
      createdAt: state.createdAt,
      lastRunAt: state.workflow?.lastRunAt,
      runCount: state.workflow?.runCount || 1
    };

    // Step 9: Create planning documents
    const files = await createPlanningDocs(milestoneData);
    const fileList = Object.values(files);

    // Step 10: Commit all files to milestone branch
    await commitPlanningDocs(milestoneNumber, fileList);

    // Step 11: Save final state
    await saveState(owner, repo, milestoneNumber, state, milestoneData.phases);

    // Step 12: Generate and post summary comment
    const summary = generateMilestoneSummary({
      milestoneNumber,
      status: "Planning Documents Created",
      files: fileList,
      requirements: {
        complete: true,
        answered: Object.keys(state.requirements.answered),
        pending: []
      },
      nextSteps: [
        "Review the planning documents in `.github/planning/milestones/`",
        "Use `@gsd-bot plan-phase` to plan each phase of the milestone",
        "Use `@gsd-bot execute-phase` to execute planned work"
      ]
    });

    await postComment(owner, repo, issueNumber, summary);

    core.info(`Milestone ${milestoneNumber} workflow complete`);

    return {
      complete: true,
      phase: "milestone-created",
      milestone: milestoneNumber,
      files: fileList.map(f => f.path),
      branch: `gsd/${milestoneNumber}`,
      message: "Milestone created successfully with planning documents"
    };

  } catch (error) {
    core.error(`Milestone workflow error: ${error.message}`);

    // Post error comment
    const errorComment = formatErrorComment(error, "milestone creation");
    await postComment(owner, repo, issueNumber, errorComment);

    throw error;
  }
}

/**
 * Generate phases from requirements answers
 * Helper function to transform requirements into phase structure
 *
 * @param {object} answers - User-provided requirements answers
 * @returns {Array} Phase definitions
 */
function generatePhasesFromRequirements(answers) {
  return [
    { name: "Foundation Setup", goal: "Initial project structure and dependencies", status: "pending", dependencies: "None" },
    { name: "Core Implementation", goal: "Main feature implementation", status: "pending", dependencies: "Phase 1" },
    { name: "Integration", goal: "Connect components and verify functionality", status: "pending", dependencies: "Phase 2" },
    { name: "Testing & Verification", goal: "Testing, bug fixes, and final verification", status: "pending", dependencies: "Phase 3" }
  ];
}
