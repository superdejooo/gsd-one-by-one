---
phase: "09-issue-tracking-integration"
plan: "03"
type: "execute"
wave: 2
depends_on: ["09-01"]
files_modified:
  - "src/milestone/phase-executor.js"
autonomous: true
must_haves:
  truths:
    - "Executor marks issues as in-progress when starting execution"
    - "Executor marks issues as complete when tasks pass verification"
    - "Status updates use existing labels infrastructure"
  artifacts:
    - path: "src/milestone/phase-executor.js"
      provides: "Issue status updates during execution"
  key_links:
    - from: "src/milestone/phase-executor.js"
      to: "src/lib/issues.js"
      via: "import { getPhaseIssues }"
    - from: "src/milestone/phase-executor.js"
      to: "src/lib/labels.js"
      via: "import { updateIssueStatus }"
---

<objective>
Integrate issue status updates into the phase executor workflow.

Purpose: As the executor completes tasks, update the corresponding GitHub issues from pending to in-progress to complete.

Output: Modified phase-executor.js that updates issue status during execution.
</objective>

<context>
@src/milestone/phase-executor.js
@src/lib/issues.js
@src/lib/labels.js
@.planning/phases/09-issue-tracking-integration/09-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add status update imports and helpers</name>
  <files>src/milestone/phase-executor.js</files>
  <action>
    Modify src/milestone/phase-executor.js to add issue status update capabilities.

    **Add imports at top (after existing imports):**
    ```javascript
    import { getPhaseIssues } from "../lib/issues.js";
    import { updateIssueStatus } from "../lib/labels.js";
    ```

    **Add helper function matchTaskToIssue(taskName, issues):**
    ```javascript
    /**
     * Find issue that matches a task name
     * @param {string} taskName - Task name from execution output
     * @param {Array<{number: number, title: string}>} issues - Phase issues
     * @returns {object|null} Matching issue or null
     */
    function matchTaskToIssue(taskName, issues) {
      // Normalize for comparison: lowercase, remove "Task N:" prefix
      const normalizedTask = taskName
        .toLowerCase()
        .replace(/^task\s*\d+:\s*/i, '')
        .trim();

      return issues.find(issue => {
        // Issue title format: "09: Task Name"
        const issueTaskName = issue.title
          .replace(/^\d+:\s*/, '')  // Remove "09: " prefix
          .toLowerCase()
          .replace(/^task\s*\d+:\s*/i, '')  // Remove any "Task N:" in title
          .trim();

        // Check for substring match (task name contained in issue title or vice versa)
        return issueTaskName.includes(normalizedTask) ||
               normalizedTask.includes(issueTaskName);
      });
    }
    ```

    **Add helper function updateIssuesForCompletedTasks(owner, repo, completedActions, issues):**
    ```javascript
    /**
     * Update issues to complete status for completed tasks
     * @param {string} owner - Repository owner
     * @param {string} repo - Repository name
     * @param {string[]} completedActions - List of completed task names
     * @param {Array<{number: number, title: string, status: string}>} issues - Phase issues
     * @returns {Promise<number>} Number of issues updated
     */
    async function updateIssuesForCompletedTasks(owner, repo, completedActions, issues) {
      let updatedCount = 0;

      for (const taskName of completedActions) {
        const matchingIssue = matchTaskToIssue(taskName, issues);

        if (matchingIssue && matchingIssue.status !== 'status:complete') {
          try {
            await updateIssueStatus(owner, repo, matchingIssue.number, 'complete');
            updatedCount++;
            core.info(`Marked issue #${matchingIssue.number} as complete`);
          } catch (error) {
            core.warning(`Failed to update issue #${matchingIssue.number}: ${error.message}`);
          }
        }
      }

      return updatedCount;
    }
    ```
  </action>
  <verify>grep -q "matchTaskToIssue" src/milestone/phase-executor.js && grep -q "updateIssuesForCompletedTasks" src/milestone/phase-executor.js</verify>
  <done>Helper functions for issue status updates exist</done>
</task>

<task type="auto">
  <name>Task 2: Integrate status updates into executePhaseExecutionWorkflow</name>
  <files>src/milestone/phase-executor.js</files>
  <action>
    Modify executePhaseExecutionWorkflow to update issue status during execution.

    **After parsing output (after Step 6 where parsed is created), add issue status updates:**

    Insert before posting the formatted comment:
    ```javascript
    // Step 7: Update issue status for completed tasks
    let issuesUpdated = 0;
    try {
      const phaseIssues = await getPhaseIssues(owner, repo, phaseNumber);

      if (phaseIssues.length > 0 && parsed.completedActions.length > 0) {
        // Mark all phase issues as in-progress at start (if still pending)
        for (const issue of phaseIssues) {
          if (issue.status === 'status:pending') {
            try {
              await updateIssueStatus(owner, repo, issue.number, 'in-progress');
              core.info(`Marked issue #${issue.number} as in-progress`);
            } catch (error) {
              core.warning(`Failed to update issue #${issue.number}: ${error.message}`);
            }
          }
        }

        // Mark completed tasks
        issuesUpdated = await updateIssuesForCompletedTasks(
          owner, repo, parsed.completedActions, phaseIssues
        );
      }
    } catch (issueError) {
      core.warning(`Issue status update failed: ${issueError.message}`);
      // Don't fail the workflow - execution succeeded, status updates are supplementary
    }
    ```

    **Update return statement to include issuesUpdated count:**

    Change the return statement (around line 227) to include issuesUpdated:
    ```javascript
    return {
      complete: !parsed.hasQuestions,
      phaseNumber,
      hasQuestions: parsed.hasQuestions,
      completedCount: parsed.completedActions.length,
      issuesUpdated,
      message: parsed.hasQuestions
        ? "Phase execution paused - questions require user input"
        : "Phase execution completed successfully"
    };
    ```
  </action>
  <verify>grep -q "getPhaseIssues" src/milestone/phase-executor.js && grep -q "issuesUpdated" src/milestone/phase-executor.js</verify>
  <done>executePhaseExecutionWorkflow updates issue status during execution</done>
</task>

</tasks>

<verification>
1. Module loads: `node -e "import('./src/milestone/phase-executor.js')"`
2. Imports getPhaseIssues from issues.js
3. Imports updateIssueStatus from labels.js
4. matchTaskToIssue handles various task name formats
5. Pending issues marked as in-progress at execution start
6. Completed tasks update matching issues to complete
7. Status update failure does not fail the workflow
</verification>

<success_criteria>
- [ ] phase-executor.js imports getPhaseIssues and updateIssueStatus
- [ ] matchTaskToIssue finds issues by normalized task name comparison
- [ ] updateIssuesForCompletedTasks updates all matching completed tasks
- [ ] Pending issues are marked in-progress at execution start
- [ ] Completed tasks have their issues marked complete
- [ ] Status update failure is logged but does not fail workflow
- [ ] Return value includes issuesUpdated count
</success_criteria>

<output>
After completion, create `.planning/phases/09-issue-tracking-integration/09-03-SUMMARY.md`
</output>
