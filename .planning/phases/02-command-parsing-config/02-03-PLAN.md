---
phase: 02-command-parsing-config
plan: 03
type: execute
wave: 3
depends_on: [02-02]
files_modified:
  - src/lib/config.js
  - src/lib/validator.js
  - src/index.js
  - action.yml
autonomous: true

must_haves:
  truths:
    - "Action loads .github/gsd-config.json from repository"
    - "Action uses default config when file not found (404)"
    - "Action validates commands against allowlist (new-milestone only for v1)"
    - "Action sanitizes arguments to prevent command injection"
    - "Action throws clear error for unknown commands"
  artifacts:
    - path: "src/lib/config.js"
      provides: "Config loading with defaults"
      exports: ["loadConfig", "getDefaultConfig"]
      min_lines: 40
    - path: "src/lib/validator.js"
      provides: "Command validation and input sanitization"
      exports: ["validateCommand", "sanitizeArguments"]
      min_lines: 40
    - path: "src/index.js"
      provides: "Main entry point with validation integration"
      min_lines: 40
    - path: "action.yml"
      provides: "Action inputs and outputs"
      min_lines: 25
  key_links:
    - from: "src/index.js"
      to: "src/lib/config.js"
      via: "import loadConfig"
      pattern: "import.*loadConfig.*from.*config"
    - from: "src/index.js"
      to: "src/lib/validator.js"
      via: "import validateCommand, sanitizeArguments"
      pattern: "import.*validateCommand.*from.*validator"
    - from: "src/index.js"
      to: "loadConfig()"
      via: "function call"
      pattern: "loadConfig\\("
    - from: "src/index.js"
      to: "validateCommand()"
      via: "function call"
      pattern: "validateCommand\\("
---

<objective>
Load config file from repository with defaults and add command validation with input sanitization.

Purpose: Enable the action to load user configuration from the repository (or use sensible defaults), validate commands against an allowlist, and sanitize user input to prevent command injection.

Output: src/lib/config.js, src/lib/validator.js, updated src/index.js and action.yml
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-command-parsing-config/02-RESEARCH.md
@.planning/STATE.md

# Existing codebase
@src/index.js (updated in 02-02)
@src/lib/parser.js (created in 02-01)
@action.yml
</context>

<tasks>

<task type="auto">
  <name>Create config loading module with defaults</name>
  <files>src/lib/config.js</files>
  <action>
Create src/lib/config.js:

```javascript
import * as github from "@actions/github";
import * as core from "@actions/core";

/**
 * Load configuration from .github/gsd-config.json or use defaults
 * @param {string} owner - Repository owner
 * @param {string} repo - Repository name
 * @returns {object} - Configuration object
 */
export async function loadConfig(owner, repo) {
  const token = core.getInput("token", { required: false }) || process.env.GITHUB_TOKEN;
  const octokit = github.getOctokit(token);

  try {
    const response = await octokit.rest.repos.getContent({
      owner,
      repo,
      path: ".github/gsd-config.json"
    });

    // Decode base64 content (GitHub API returns base64 for files)
    const content = Buffer.from(response.data.content, "base64").toString("utf-8");
    const config = JSON.parse(content);

    core.info("Loaded config from .github/gsd-config.json");
    return config;
  } catch (error) {
    if (error.status === 404) {
      core.info("Config file not found, using defaults");
      return getDefaultConfig();
    }
    throw new Error(`Failed to load config: ${error.message}`);
  }
}

/**
 * Get default configuration
 * @returns {object} - Default config object
 */
function getDefaultConfig() {
  return {
    labels: {
      phases: {
        "01-github-action-foundation": "Phase 1: Foundation",
        "02-command-parsing-config": "Phase 2: Command Parsing & Config",
        "03-claude-code-router": "Phase 3: CCR Integration",
        "04-communication-layer": "Phase 4: Communication",
        "05-milestone-creation": "Phase 5: Milestone Creation",
        "06-authorization-check": "Phase 6: Authorization"
      },
      status: {
        "todo": "To Do",
        "in-progress": "In Progress",
        "done": "Done",
        "blocked": "Blocked"
      }
    },
    paths: {
      planning: ".github/planning/",
      milestones: ".github/planning/milestones/",
      phases: ".github/planning/phases/"
    }
  };
}
```

Pattern from RESEARCH.md - Pattern 3 (GitHub API File Fetching).

Why this structure:
- Uses @actions/github for authenticated API calls
- Handles 404 errors gracefully (CONF-04 requirement)
- Decodes base64 content before parsing JSON
- Provides sensible defaults for labels and paths
  </action>
  <verify>
cat src/lib/config.js | grep -q "export.*loadConfig" && cat src/lib/config.js | grep -q "getDefaultConfig" && cat src/lib/config.js | grep -q "Buffer.from"
  </verify>
  <done>
config.js contains:
- loadConfig function that fetches .github/gsd-config.json
- Handles 404 error by returning defaults
- Decodes base64 content from GitHub API
- getDefaultConfig function with sensible defaults
  </done>
</task>

<task type="auto">
  <name>Create validator module for command validation and sanitization</name>
  <files>src/lib/validator.js</files>
  <action>
Create src/lib/validator.js:

```javascript
import * as core from "@actions/core";

/**
 * Allowlist of valid commands
 * For v1, only new-milestone is implemented
 */
const ALLOWED_COMMANDS = ["new-milestone"];

/**
 * Validate command against allowlist
 * @param {string} command - Command name
 * @throws {Error} - If command is not in allowlist or has invalid format
 */
export function validateCommand(command) {
  // Allowlist validation (not denylist)
  if (!ALLOWED_COMMANDS.includes(command)) {
    throw new Error(
      `Unknown command: ${command}. Valid commands: ${ALLOWED_COMMANDS.join(", ")}`
    );
  }

  // Format validation (kebab-case only)
  if (!/^[a-z0-9-]+$/.test(command)) {
    throw new Error(`Invalid command format: ${command}. Must be kebab-case`);
  }

  core.info(`Command validated: ${command}`);
}

/**
 * Sanitize arguments to prevent command injection
 * Removes shell metacharacters and validates length
 * @param {object} args - Arguments object
 * @throws {Error} - If validation fails
 * @returns {object} - Sanitized arguments
 */
export function sanitizeArguments(args) {
  const sanitized = {};

  Object.keys(args).forEach((key) => {
    let value = args[key];

    // Check for empty values
    if (!value || value.length === 0) {
      throw new Error(`Argument ${key} cannot be empty`);
    }

    // Check for reasonable length limits (500 chars)
    if (value.length > 500) {
      throw new Error(`Argument ${key} exceeds maximum length (500 chars)`);
    }

    // Remove shell metacharacters to prevent command injection
    // Source: OWASP Input Validation Cheat Sheet
    value = value.replace(/[;&|`$()]/g, "");

    sanitized[key] = value.trim();
  });

  return sanitized;
}
```

Pattern from RESEARCH.md - Pattern 4 (Input Validation & Sanitization).

Why this structure:
- Allowlist validation (not denylist) per OWASP guidelines
- Only "new-milestone" in allowlist for v1
- Sanitizes shell metacharacters to prevent injection
- Validates argument length to prevent DoS
  </action>
  <verify>
cat src/lib/validator.js | grep -q "export.*validateCommand" && cat src/lib/validator.js | grep -q "export.*sanitizeArguments" && cat src/lib/validator.js | grep -q "ALLOWED_COMMANDS"
  </verify>
  <done>
validator.js contains:
- validateCommand function with allowlist
- Allows only "new-milestone" for v1
- sanitizeArguments function that removes shell metacharacters
- Validates argument length (500 char max)
  </done>
</task>

<task type="auto">
  <name>Integrate config loading and validation into main action</name>
  <files>src/index.js</files>
  <action>
Update src/index.js to integrate config and validation:

1. Add imports:
```javascript
import { loadConfig } from "./lib/config.js";
import { validateCommand, sanitizeArguments } from "./lib/validator.js";
```

2. After parsing logic (inside the else block), add validation:
```javascript
// Validate command
try {
  validateCommand(parsed.command);

  // Sanitize arguments
  const sanitizedArgs = args ? sanitizeArguments(args) : {};

  // Load configuration
  const config = await loadConfig(repoOwner, repoName);

  core.info("Configuration loaded and validated");
  core.info(`Config paths: ${JSON.stringify(config.paths)}`);

  // Set additional outputs
  core.setOutput("config-loaded", "true");
  core.setOutput("arguments", JSON.stringify(sanitizedArgs));

  // TODO: Execute command logic in later phases (Phase 4+)
} catch (error) {
  core.setFailed(error.message);
  core.setOutput("command-found", "false");
  core.setOutput("config-loaded", "false");
}
```

Why this structure:
- Validates command before loading config (fail fast)
- Sanitizes arguments to prevent injection
- Loads config for later phases to use
- Sets outputs for use in workflow steps
  </action>
  <verify>
cat src/index.js | grep -q "import.*loadConfig" && cat src/index.js | grep -q "import.*validateCommand" && cat src/index.js | grep -q "validateCommand\\(parsed.command\\)" && cat src/index.js | grep -q "loadConfig\\("
  </verify>
  <done>
src/index.js updated to:
- Import loadConfig, validateCommand, sanitizeArguments
- Call validateCommand with parsed.command
- Call sanitizeArguments with args
- Call loadConfig with repoOwner and repoName
- Handle validation errors gracefully
- Set config-loaded output
  </done>
</task>

<task type="auto">
  <name>Add token input and command output to action.yml</name>
  <files>action.yml</files>
  <action>
Update action.yml:

1. Add token input:
```yaml
inputs:
  issue-number:
    description: 'The issue or PR number'
    required: true
  repo-owner:
    description: 'The repository owner'
    required: true
  repo-name:
    description: 'The repository name'
    required: true
  comment-body:
    description: 'The comment body text'
    required: true
  token:
    description: 'GitHub token for API access'
    required: false
    default: ${{ github.token }}
```

2. Add additional outputs:
```yaml
outputs:
  response-posted:
    description: 'Whether the response was successfully posted'
  command-found:
    description: 'Whether an @gsd-bot command was found'
  command:
    description: 'The extracted command name'
  config-loaded:
    description: 'Whether the configuration was loaded'
  arguments:
    description: 'Parsed and sanitized arguments (JSON string)'
```

Why these additions:
- Token input for config file fetching via GitHub API
- Additional outputs for workflow step conditions
- Token defaults to github.token for convenience
  </action>
  <verify>
cat action.yml | grep -q "token:" && cat action.yml | grep -q "command-found:" && cat action.yml | grep -q "config-loaded:" && cat action.yml | grep -q "arguments:"
  </verify>
  <done>
action.yml updated to:
- Include token input with default to github.token
- Include command-found output
- Include config-loaded output
- Include arguments output (JSON string)
  </done>
</task>

</tasks>

<verification>
After plan completion:
1. Check src/lib/config.js exists and exports loadConfig
2. Check src/lib/validator.js exists and exports validateCommand and sanitizeArguments
3. Check src/index.js imports and calls all three functions
4. Check action.yml has token input and additional outputs
5. Test validation:
   - "new-milestone" passes validation
   - "invalid-command" throws error with list of valid commands
6. Test sanitization:
   - "--title='Feature X'" sanitizes to title: "Feature X"
   - "--title='rm -rf /'" sanitizes to title: "rm -rf "
7. Test config loading:
   - 404 error returns defaults
   - Valid config file loads successfully
</verification>

<success_criteria>
- src/lib/config.js loads .github/gsd-config.json with base64 decoding
- src/lib/config.js handles 404 with defaults
- src/lib/validator.js validates commands against allowlist
- src/lib/validator.js sanitizes arguments (removes shell metacharacters)
- src/index.js integrates all three functions
- action.yml has token input and additional outputs
- Validation errors are handled with clear messages
- Config defaults are sensible and usable
</success_criteria>

<output>
After completion, create `.planning/phases/02-command-parsing-config/02-03-SUMMARY.md`
</output>
