---
phase: "08-phase-execution-command"
plan: "01"
type: "execute"
wave: 1
depends_on: []
files_modified:
  - "src/lib/validator.js"
  - "src/index.js"
  - "src/milestone/phase-executor.js"
autonomous: true
must_haves:
  truths:
    - "GitHub Action recognizes 'execute-phase' command"
    - "CCR executes GSD execute-plan command with 30-minute timeout"
    - "Output is parsed for completed actions, next steps, and questions"
    - "Structured comment posted to GitHub with parsed sections"
  artifacts:
    - path: "src/lib/validator.js"
      provides: "ALLOWLIST includes 'execute-phase'"
    - path: "src/index.js"
      provides: "Dispatch for execute-phase command"
    - path: "src/milestone/phase-executor.js"
      provides: "executePhaseExecutionWorkflow: runs CCR, parses output, posts structured comment"
  key_links:
    - from: "src/lib/validator.js"
      to: "src/milestone/phase-executor.js"
      via: "command passes validation"
    - from: "src/index.js"
      to: "src/milestone/phase-executor.js"
      via: "executePhaseExecutionWorkflow call"
    - from: "src/milestone/phase-executor.js"
      to: "CCR via exec()"
      via: "echo '/gsd:execute-plan N' | ccr code --print > output.txt"
---

<objective>
Wire GSD's built-in execute-plan command into the GitHub Action with enhanced output parsing.

The flow:

1. User comments: `@gsd-bot execute-phase 8`
2. Action validates command, runs CCR with 30-minute timeout
3. CCR executes GSD: `echo "/gsd:execute-plan 8" | ccr code --print > output.txt`
4. Action waits for exit, reads output.txt
5. Action parses output for completed actions, next steps, questions
6. Action posts structured comment to GitHub

Key differences from plan-phase (Phase 7):

- 30-minute timeout (vs 10 min) - execution takes longer than planning
- Parse GSD output to extract sections (completed, next steps, questions)
- Format structured comment with sections instead of raw pass-through
- Questions section prompts user to reply for conversational continuation

Purpose: Enable phase execution through GitHub issue comments with progress visibility.
Output: Working execute-phase command with structured output parsing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-phase-execution-command/08-CONTEXT.md
@.planning/phases/08-phase-execution-command/08-RESEARCH.md
@.planning/phases/07-phase-planning-command/07-01-SUMMARY.md
@src/milestone/phase-planner.js
@src/index.js
@src/lib/validator.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add execute-phase to ALLOWLIST</name>
  <files>src/lib/validator.js</files>
  <action>
    Add "execute-phase" to the ALLOWED_COMMANDS array in src/lib/validator.js.

    Current line 7: `const ALLOWED_COMMANDS = ["new-milestone", "plan-phase"];`

    Change to: `const ALLOWED_COMMANDS = ["new-milestone", "plan-phase", "execute-phase"];`

    Keep existing validateCommand and sanitizeArguments functions unchanged.

  </action>
  <verify>grep -n 'ALLOWED_COMMANDS' src/lib/validator.js | grep -q '"execute-phase"'</verify>
  <done>Command allowlist includes "execute-phase"</done>
</task>

<task type="auto">
  <name>Task 2: Create phase-executor.js module</name>
  <files>src/milestone/phase-executor.js</files>
  <action>
    Create src/milestone/phase-executor.js following the phase-planner.js pattern with these enhancements:

    **Imports (same as phase-planner.js):**
    ```javascript
    import * as core from "@actions/core";
    import * as github from "@actions/github";
    import { exec } from "child_process";
    import { promisify } from "util";
    import fs from "fs/promises";
    import { postComment, getWorkflowRunUrl } from "../lib/github.js";
    import { formatErrorComment } from "../errors/formatter.js";

    const execAsync = promisify(exec);
    ```

    **parsePhaseNumber function:**
    Copy exactly from phase-planner.js (same argument parsing logic).
    Supports: --phase N, -p N, standalone N formats.
    Throws descriptive error if phase number cannot be parsed.

    **parseExecutionOutput function (NEW):**
    ```javascript
    /**
     * Parse GSD execution output to extract structured sections
     * @param {string} output - Raw GSD output
     * @returns {object} Parsed sections
     */
    function parseExecutionOutput(output) {
      const sections = {
        completedActions: [],
        nextSteps: [],
        questions: [],
        hasQuestions: false
      };

      // Extract completed actions (checkmarks, "completed", task markers)
      const completedPattern = /(?:[*-]\s*)?(?:\[x\]|completed?:?|done:?)\s*(.+)/gi;
      let match;
      while ((match = completedPattern.exec(output)) !== null) {
        sections.completedActions.push(match[1].trim());
      }

      // Extract next steps section
      const nextStepsMatch = output.match(/(?:##?\s*)?next steps?:?\s*\n((?:[-*]\s*.+\n?)+)/i);
      if (nextStepsMatch) {
        sections.nextSteps = nextStepsMatch[1]
          .split('\n')
          .filter(line => line.trim().startsWith('-') || line.trim().startsWith('*'))
          .map(line => line.replace(/^[-*]\s*/, '').trim())
          .filter(line => line.length > 0);
      }

      // Extract questions (agent asking for input)
      const questionsMatch = output.match(/(?:##?\s*)?questions?:?\s*\n((?:[-*]\s*.+\n?)+)/i);
      if (questionsMatch) {
        sections.questions = questionsMatch[1]
          .split('\n')
          .filter(line => line.trim().startsWith('-') || line.trim().startsWith('*'))
          .map(line => line.replace(/^[-*]\s*/, '').trim())
          .filter(line => line.length > 0);
        sections.hasQuestions = sections.questions.length > 0;
      }

      return sections;
    }
    ```

    **formatExecutionComment function (NEW):**
    ```javascript
    /**
     * Format parsed output into structured GitHub comment
     * @param {object} parsed - Parsed sections from parseExecutionOutput
     * @param {string} rawOutput - Original raw output for details section
     * @returns {string} Formatted markdown comment
     */
    function formatExecutionComment(parsed, rawOutput) {
      let comment = `## Phase Execution Update\n\n`;

      if (parsed.completedActions.length > 0) {
        comment += `### Completed\n\n`;
        parsed.completedActions.forEach(action => {
          comment += `- [x] ${action}\n`;
        });
        comment += `\n`;
      }

      if (parsed.nextSteps.length > 0) {
        comment += `### Next Steps\n\n`;
        parsed.nextSteps.forEach(step => {
          comment += `- ${step}\n`;
        });
        comment += `\n`;
      }

      if (parsed.questions.length > 0) {
        comment += `### Questions\n\n`;
        parsed.questions.forEach(question => {
          comment += `- ${question}\n`;
        });
        comment += `\n**Reply to this comment to answer these questions. The workflow will resume when you reply.**\n\n`;
      }

      // Include raw output in collapsible section
      comment += `<details>\n<summary>Full Output</summary>\n\n\`\`\`\n${rawOutput}\n\`\`\`\n\n</details>`;

      return comment;
    }
    ```

    **executePhaseExecutionWorkflow function:**
    Similar to executePhaseWorkflow from phase-planner.js with these changes:
    1. Timeout: 1800000 (30 minutes) instead of 600000 (10 minutes)
    2. GSD command: `/gsd:execute-plan ${phaseNumber}` (not plan-phase)
    3. Output parsing: Call parseExecutionOutput(output) before posting
    4. Comment formatting: Call formatExecutionComment(parsed, output) for structured output
    5. Return includes hasQuestions flag for caller awareness

    ```javascript
    export async function executePhaseExecutionWorkflow(context, commandArgs) {
      const { owner, repo, issueNumber } = context;
      const workflowUrl = getWorkflowRunUrl();

      core.info(`Starting phase execution workflow for ${owner}/${repo}#${issueNumber}`);

      try {
        // Step 1: Parse phase number
        const phaseNumber = parsePhaseNumber(commandArgs);
        core.info(`Parsed phase number: ${phaseNumber}`);

        // Step 2: Execute GSD execute-plan via CCR
        // 30 minute timeout - execution takes longer than planning
        const outputPath = `output-${Date.now()}.txt`;
        const command = `echo "/gsd:execute-plan ${phaseNumber}" | ccr code --print > ${outputPath}`;

        core.info(`Executing: ${command}`);

        let exitCode = 0;
        try {
          await execAsync(command, { timeout: 1800000 }); // 30 min timeout
        } catch (error) {
          exitCode = error.code || 1;
          core.warning(`Command exited with code ${exitCode}`);
        }

        // Step 3: Read captured output
        let output = "";
        try {
          output = await fs.readFile(outputPath, "utf-8");
        } catch (error) {
          output = "(No output captured)";
        }

        // Step 4: Validate for errors
        const isError = exitCode !== 0 ||
          /Permission Denied|Authorization failed|not authorized/i.test(output) ||
          /Error:|Something went wrong|failed/i.test(output) ||
          /Unknown command|invalid arguments|validation failed/i.test(output);

        // Step 5: Post result to GitHub
        if (isError) {
          const errorMsg = formatErrorComment(new Error(output.trim()), workflowUrl);
          await postComment(owner, repo, issueNumber, errorMsg);
          throw new Error(`Phase execution failed: ${output.substring(0, 500)}`);
        }

        // Step 6: Parse and format structured output
        const parsed = parseExecutionOutput(output);
        const formattedComment = formatExecutionComment(parsed, output);
        await postComment(owner, repo, issueNumber, formattedComment);

        // Cleanup output file
        try {
          await fs.unlink(outputPath);
        } catch (e) {
          core.warning(`Failed to cleanup output file: ${e.message}`);
        }

        core.info(`Phase ${phaseNumber} execution workflow complete`);

        return {
          complete: !parsed.hasQuestions,
          phaseNumber,
          hasQuestions: parsed.hasQuestions,
          completedCount: parsed.completedActions.length,
          message: parsed.hasQuestions
            ? "Phase execution paused - questions require user input"
            : "Phase execution completed successfully"
        };

      } catch (error) {
        core.error(`Phase execution workflow error: ${error.message}`);
        const errorComment = formatErrorComment(error, workflowUrl);
        await postComment(owner, repo, issueNumber, errorComment);
        throw error;
      }
    }
    ```

    **Module documentation header:**
    Add JSDoc comment at top:
    ```javascript
    /**
     * Phase Execution Workflow Module
     *
     * Executes GSD's built-in execute-plan command via CCR (Claude Code Router)
     * with enhanced output parsing for structured GitHub comments.
     *
     * Key differences from phase-planner.js:
     * - 30-minute timeout (execution takes longer than planning)
     * - Parses output to extract completed actions, next steps, questions
     * - Posts structured comment instead of raw pass-through
     * - Returns hasQuestions flag for conversational continuation
     */
    ```

  </action>
  <verify>grep -q 'export.*parsePhaseNumber' src/milestone/phase-executor.js && grep -q 'export.*executePhaseExecutionWorkflow' src/milestone/phase-executor.js && grep -q 'parseExecutionOutput' src/milestone/phase-executor.js && grep -q 'timeout: 1800000' src/milestone/phase-executor.js</verify>
  <done>phase-executor.js exists with enhanced parsing and 30-minute timeout</done>
</task>

<task type="auto">
  <name>Task 3: Update command dispatch in index.js</name>
  <files>src/index.js</files>
  <action>
    Add execute-phase dispatch to src/index.js.

    **Add import** after line 15 (after phase-planner import):
    ```javascript
    import { executePhaseExecutionWorkflow } from "./milestone/phase-executor.js";
    ```

    **Add module trigger** after line 25 (after _phasePlannerModule):
    ```javascript
    const _phaseExecutorModule = { executePhaseExecutionWorkflow };
    ```

    **Update console.log** on line 27 to include _phaseExecutorModule:
    Add `!!_phaseExecutorModule` to the modules loaded log.

    **Add dispatch block** after the plan-phase dispatch block (after line 110):
    ```javascript
    // Command dispatch for phase execution workflow
    if (parsed.command === "execute-phase") {
      core.info("Dispatching to phase execution workflow");
      const result = await executePhaseExecutionWorkflow(
        { owner: repoOwner, repo: repoName, issueNumber: github.context.issue?.number },
        sanitizedArgs
      );
      core.setOutput("phase-executed", result.complete);
      core.setOutput("phase-number", result.phaseNumber);
      core.setOutput("has-questions", result.hasQuestions);
      return { commandFound: true, command: parsed.command, ...result };
    }
    ```

    The dispatch pattern follows exactly the plan-phase pattern from Phase 7.

  </action>
  <verify>grep -q 'executePhaseExecutionWorkflow' src/index.js && grep -q 'if (parsed.command === "execute-phase")' src/index.js && grep -q '_phaseExecutorModule' src/index.js</verify>
  <done>Command dispatch includes execute-phase handler</done>
</task>

</tasks>

<verification>
1. Test allowlist: `node -e "import('./src/lib/validator.js').then(m => m.validateCommand('execute-phase'))"`
2. Module loads: `node -e "import('./src/milestone/phase-executor.js').then(m => console.log(Object.keys(m)))"`
3. parsePhaseNumber tests: --phase 8, -p 8, standalone 8
4. parseExecutionOutput parses markdown sections correctly
5. formatExecutionComment produces structured markdown
6. executePhaseExecutionWorkflow uses 30-minute timeout
7. index.js dispatches execute-phase to phase-executor
</verification>

<success_criteria>

- [ ] ALLOWLIST includes "execute-phase"
- [ ] src/milestone/phase-executor.js exists with parsePhaseNumber, parseExecutionOutput, formatExecutionComment, executePhaseExecutionWorkflow
- [ ] executePhaseExecutionWorkflow uses 30-minute timeout (1800000ms)
- [ ] executePhaseExecutionWorkflow calls GSD execute-plan (not plan-phase)
- [ ] Output is parsed for completed actions, next steps, questions
- [ ] Structured comment posted to GitHub with parsed sections
- [ ] index.js dispatches execute-phase to phase-executor
- [ ] hasQuestions flag returned when questions detected in output
      </success_criteria>

<output>
After completion, create `.planning/phases/08-phase-execution-command/08-01-SUMMARY.md`
</output>
