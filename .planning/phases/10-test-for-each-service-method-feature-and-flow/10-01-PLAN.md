---
phase: 10-test-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - vitest.config.js
  - test/setup.js
  - package.json
autonomous: true

must_haves:
  truths:
    - "npm test runs Vitest successfully"
    - "npm run test:coverage generates coverage report"
    - "Tests auto-discover .test.js files in src/"
  artifacts:
    - path: "vitest.config.js"
      provides: "Vitest configuration for Node.js 24 ESM"
      contains: "coverage"
    - path: "test/setup.js"
      provides: "Global test setup with fetch mocking"
      contains: "createFetchMock"
    - path: "package.json"
      provides: "Test scripts"
      contains: "vitest"
  key_links:
    - from: "vitest.config.js"
      to: "test/setup.js"
      via: "setupFiles config"
      pattern: "setupFiles.*test/setup"
---

<objective>
Set up comprehensive test infrastructure for the GSD GitHub Action.

Purpose: Enable consistent, fast testing across all 23 source modules with proper mocking infrastructure for ESM, GitHub API, and child_process.

Output: Working vitest configuration with coverage thresholds, global test setup for fetch mocking, and npm test scripts.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-test-for-each-service-method-feature-and-flow/10-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install test dependencies and configure Vitest</name>
  <files>package.json, vitest.config.js</files>
  <action>
  1. Install vitest-fetch-mock as dev dependency:
     ```
     npm install -D vitest-fetch-mock
     ```

  2. Update package.json scripts:
     - "test": "vitest"
     - "test:run": "vitest run"
     - "test:coverage": "vitest --coverage"
     - "test:ui": "vitest --ui" (optional, for interactive mode)

  3. Create vitest.config.js at project root with:
     - globals: false (explicit imports preferred for clarity)
     - environment: 'node' (not jsdom - this is a CLI tool)
     - coverage.provider: 'v8' (native Node.js coverage)
     - coverage.reporter: ['text', 'json', 'html', 'lcov']
     - coverage.exclude: node_modules, dist, *.test.js, *.config.js
     - coverage.thresholds: 80% for lines/functions/branches/statements
     - setupFiles: ['./test/setup.js']
     - include: ['src/**/*.test.js'] (colocated tests)

  Use ESM syntax (import/export) matching project convention.
  </action>
  <verify>Run `npm test -- --run` - should find 0 tests but exit cleanly with config loaded</verify>
  <done>vitest.config.js exists with coverage thresholds, package.json has test scripts</done>
</task>

<task type="auto">
  <name>Task 2: Create global test setup with fetch mocking</name>
  <files>test/setup.js</files>
  <action>
  1. Create test/ directory if not exists

  2. Create test/setup.js with:
     - Import { beforeAll, afterEach, vi } from 'vitest'
     - Import createFetchMock from 'vitest-fetch-mock'
     - Enable fetch mocking globally: fetchMocker.enableMocks()
     - beforeAll hook for any global setup
     - afterEach hook that:
       - Calls vi.clearAllMocks() to reset mock call history
       - Calls fetchMocker.resetMocks() to reset fetch mock state
     - Export fetchMocker for use in individual test files if needed

  3. Add JSDoc comment explaining the setup file's purpose

  This setup file ensures all tests have consistent mock state and fetch mocking available.
  </action>
  <verify>Inspect test/setup.js - should have fetch mock setup and cleanup hooks</verify>
  <done>test/setup.js exists with fetch mock initialization and afterEach cleanup</done>
</task>

<task type="auto">
  <name>Task 3: Create sample test to verify infrastructure</name>
  <files>src/lib/parser.test.js</files>
  <action>
  1. Create src/lib/parser.test.js as a simple validation test:
     - Import { describe, it, expect } from 'vitest'
     - Import { parseComment, parseArguments } from './parser.js'
     - Add one simple test case for parseComment:
       - "returns null when bot not mentioned"
       - Input: "Regular comment"
       - Expected: null
     - Add one simple test case for parseArguments:
       - "returns empty object for empty string"
       - Input: ""
       - Expected: {}

  This is NOT the full parser test suite - just a smoke test to verify infrastructure works.
  Full parser tests will be in Plan 02.

  2. Run npm test to verify:
     - Test file is discovered
     - Tests pass
     - Coverage report is generated
  </action>
  <verify>Run `npm test -- --run` - should show 2 passing tests and coverage output</verify>
  <done>Infrastructure verified: tests run, coverage reports, fetch mocking available</done>
</task>

</tasks>

<verification>
1. `npm test -- --run` executes without errors
2. vitest.config.js has all required settings (coverage, setupFiles, include pattern)
3. test/setup.js initializes fetch mocking globally
4. Coverage report shows src/lib/parser.js partial coverage
5. No Jest dependencies (vitest only)
</verification>

<success_criteria>
- vitest.config.js created with ESM, Node.js 24 compatible settings
- test/setup.js provides global fetch mock and cleanup
- package.json has test, test:run, test:coverage scripts
- Sample test passes, proving infrastructure works
- Coverage thresholds set to 80%
</success_criteria>

<output>
After completion, create `.planning/phases/10-test-for-each-service-method-feature-and-flow/10-01-SUMMARY.md`
</output>
