---
phase: 10-test-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - vitest.config.js
  - test/setup.js
  - package.json
autonomous: true

must_haves:
  truths:
    - "npm test runs Vitest successfully"
    - "npm run test:coverage generates coverage report"
    - "Tests auto-discover .test.js files in src/"
  artifacts:
    - path: "vitest.config.js"
      provides: "Vitest configuration for Node.js 24 ESM"
      contains: "coverage"
    - path: "test/setup.js"
      provides: "Global test setup with fetch mocking"
      contains: "createFetchMock"
    - path: "package.json"
      provides: "Test scripts"
      contains: "vitest"
  key_links:
    - from: "vitest.config.js"
      to: "test/setup.js"
      via: "setupFiles config"
      pattern: "setupFiles.*test/setup"
---

<objective>
Set up comprehensive test infrastructure for the GSD GitHub Action.

Purpose: Enable consistent, fast testing across all 23 source modules with proper mocking infrastructure for ESM, GitHub API, and child_process.

Output: Working vitest configuration with coverage thresholds, global test setup for fetch mocking, and npm test scripts.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-test-for-each-service-method-feature-and-flow/10-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install test dependencies and configure Vitest</name>
  <files>package.json, vitest.config.js</files>
  <action>
  1. Install vitest-fetch-mock and coverage provider as dev dependencies:
     ```
     npm install -D vitest-fetch-mock @vitest/coverage-v8
     ```

     NOTE: The @vitest/coverage-v8 package is REQUIRED because vitest.config.js uses coverage.provider: 'v8'.

2. Update package.json scripts:
   - "test": "vitest"
   - "test:run": "vitest run"
   - "test:coverage": "vitest --coverage"
   - "test:ui": "vitest --ui" (optional, for interactive mode)

3. Create vitest.config.js at project root with:
   - globals: false (explicit imports preferred for clarity)
   - environment: 'node' (not jsdom - this is a CLI tool)
   - coverage.provider: 'v8' (native Node.js coverage)
   - coverage.reporter: ['text', 'json', 'html', 'lcov']
   - coverage.exclude: node*modules, dist, *.test.js, \_.config.js
   - coverage.thresholds: 80% for lines/functions/branches/statements
   - setupFiles: ['./test/setup.js']
   - include: ['src/**/*.test.js'] (colocated tests)

Use ESM syntax (import/export) matching project convention.
</action>
<verify>Run `npm test -- --run` - should find 0 tests but exit cleanly with config loaded</verify>
<done>vitest.config.js exists with coverage thresholds, package.json has test scripts</done>
</task>

<task type="auto">
  <name>Task 2: Create global test setup with fetch mocking and @actions mocks</name>
  <files>test/setup.js</files>
  <action>
  1. Create test/ directory if not exists

2. Create test/setup.js with CRITICAL global mocks:

   **IMPORTANT**: src/lib/github.js executes at module load time:

   ```javascript
   const token = core.getInput("token") || process.env.GITHUB_TOKEN;
   export const octokit = getOctokit(token);
   ```

   This means @actions/core and @actions/github MUST be mocked globally
   BEFORE any module that imports github.js is loaded.

   ```javascript
   /**
    * Global test setup for GSD GitHub Action
    *
    * CRITICAL: @actions/core and @actions/github must be mocked here
    * because src/lib/github.js executes getOctokit() at module load time.
    * Without these global mocks, any test importing modules that use
    * github.js will fail with "getInput is not a function" errors.
    */
   import { vi, afterEach } from "vitest";
   import createFetchMock from "vitest-fetch-mock";

   // ============================================================
   // GLOBAL MOCKS FOR @actions PACKAGES
   // These MUST be defined before any source modules are imported
   // ============================================================

   // Mock @actions/core - prevents github.js from failing on import
   vi.mock("@actions/core", () => ({
     getInput: vi.fn(() => "mock-token"),
     setOutput: vi.fn(),
     setFailed: vi.fn(),
     info: vi.fn(),
     debug: vi.fn(),
     warning: vi.fn(),
     error: vi.fn(),
   }));

   // Mock @actions/github with full context
   vi.mock("@actions/github", () => ({
     getOctokit: vi.fn(() => ({
       rest: {
         issues: {
           createComment: vi.fn(),
           listComments: vi.fn(),
           addLabels: vi.fn(),
           setLabels: vi.fn(),
           listLabelsOnIssue: vi.fn(),
           listLabelsForRepo: vi.fn(),
           createLabel: vi.fn(),
         },
         repos: {
           getCollaboratorPermissionLevel: vi.fn(),
         },
       },
       graphql: vi.fn(),
       paginate: vi.fn(),
     })),
     context: {
       repo: { owner: "test-owner", repo: "test-repo" },
       issue: { number: 123 },
       payload: {
         sender: { login: "test-user" },
         comment: { id: 456 },
         issue: { number: 123 },
       },
       token: "mock-token",
       server_url: "https://github.com",
       repository: "test-owner/test-repo",
       run_id: "12345",
       run_attempt: "1",
     },
   }));

   // ============================================================
   // FETCH MOCKING
   // ============================================================
   const fetchMocker = createFetchMock(vi);
   fetchMocker.enableMocks();

   // ============================================================
   // CLEANUP
   // ============================================================
   afterEach(() => {
     vi.clearAllMocks();
     fetchMocker.resetMocks();
   });

   export { fetchMocker };
   ```

3. This setup file ensures: - @actions packages are mocked before any source imports - github.js can be imported without runtime errors - Consistent mock context across all tests - Individual tests can override with vi.mocked() as needed
   </action>
   <verify>Inspect test/setup.js - should have @actions mocks AND fetch mock setup</verify>
   <done>test/setup.js exists with global @actions mocks and fetch mock initialization</done>
   </task>

<task type="auto">
  <name>Task 3: Create sample test to verify infrastructure</name>
  <files>src/lib/parser.test.js</files>
  <action>
  1. Create src/lib/parser.test.js as a simple validation test:
     - Import { describe, it, expect } from 'vitest'
     - Import { parseComment, parseArguments } from './parser.js'
     - Add one simple test case for parseComment:
       - "returns null when bot not mentioned"
       - Input: "Regular comment"
       - Expected: null
     - Add one simple test case for parseArguments:
       - "returns empty object for empty string"
       - Input: ""
       - Expected: {}

This is NOT the full parser test suite - just a smoke test to verify infrastructure works.
Full parser tests will be in Plan 02.

2. Run npm test to verify: - Test file is discovered - Tests pass - Coverage report is generated
   </action>
   <verify>Run `npm test -- --run` - should show 2 passing tests and coverage output</verify>
   <done>Infrastructure verified: tests run, coverage reports, fetch mocking available</done>
   </task>

</tasks>

<verification>
1. `npm test -- --run` executes without errors
2. vitest.config.js has all required settings (coverage, setupFiles, include pattern)
3. test/setup.js initializes fetch mocking globally
4. Coverage report shows src/lib/parser.js partial coverage
5. No Jest dependencies (vitest only)
</verification>

<success_criteria>

- vitest.config.js created with ESM, Node.js 24 compatible settings
- test/setup.js provides global fetch mock and cleanup
- package.json has test, test:run, test:coverage scripts
- Sample test passes, proving infrastructure works
- Coverage thresholds set to 80%
  </success_criteria>

<output>
After completion, create `.planning/phases/10-test-for-each-service-method-feature-and-flow/10-01-SUMMARY.md`
</output>
