---
phase: 10-test-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/lib/parser.test.js
  - src/lib/validator.test.js
  - src/errors/formatter.test.js
  - src/git/branches.test.js
  - src/llm/prompts.test.js
  - src/auth/errors.test.js
autonomous: true

must_haves:
  truths:
    - "All pure function modules have comprehensive test coverage"
    - "Tests verify edge cases and error conditions"
    - "No mocking required - tests use real function execution"
  artifacts:
    - path: "src/lib/parser.test.js"
      provides: "Tests for parseComment and parseArguments"
      min_lines: 60
    - path: "src/lib/validator.test.js"
      provides: "Tests for validateCommand and sanitizeArguments"
      min_lines: 50
    - path: "src/errors/formatter.test.js"
      provides: "Tests for formatErrorComment and formatSuccessComment"
      min_lines: 40
    - path: "src/git/branches.test.js"
      provides: "Tests for slugify function"
      min_lines: 30
    - path: "src/llm/prompts.test.js"
      provides: "Tests for createMilestonePrompt"
      min_lines: 20
    - path: "src/auth/errors.test.js"
      provides: "Tests for AuthorizationError and formatAuthorizationError"
      min_lines: 30
  key_links:
    - from: "src/lib/parser.test.js"
      to: "src/lib/parser.js"
      via: "ESM import"
      pattern: "import.*from.*parser"
---

<objective>
Create comprehensive unit tests for all pure logic modules that require no mocking.

Purpose: Establish baseline test coverage for 6 modules with pure functions (no external dependencies like GitHub API, child_process, or @actions packages).

Output: Test files colocated with source modules, each with >90% coverage of their module.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-test-for-each-service-method-feature-and-flow/10-RESEARCH.md
@.planning/phases/10-test-for-each-service-method-feature-and-flow/10-01-SUMMARY.md
@src/lib/parser.js
@src/lib/validator.js
@src/errors/formatter.js
@src/git/branches.js
@src/llm/prompts.js
@src/auth/errors.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Complete parser.js and validator.js tests</name>
  <files>src/lib/parser.test.js, src/lib/validator.test.js</files>
  <action>
  **parser.test.js** - Expand from infrastructure smoke test to full coverage:

parseComment tests:

- Returns null when bot not mentioned
- Returns null when mentioned but no command follows
- Extracts command from "@gsd-bot new-milestone"
- Extracts command and args from "@gsd-bot plan-phase --phase=7"
- Normalizes command to lowercase ("@gsd-bot NEW-MILESTONE" -> "new-milestone")
- Handles multiline comment (normalizes newlines)
- Case-insensitive bot mention ("@GSD-BOT" works)

parseArguments tests:

- Returns empty object for empty string
- Parses --key=value format
- Parses quoted values: --name="My Milestone"
- Parses single-quoted values: --name='My Milestone'
- Handles multiple arguments
- Ignores malformed arguments (no =)

**validator.test.js** - Test validateCommand and sanitizeArguments:

validateCommand tests:

- Accepts "new-milestone" (in allowlist)
- Accepts "plan-phase" (in allowlist)
- Accepts "execute-phase" (in allowlist)
- Throws for unknown command "invalid-command"
- Throws for non-kebab-case command "NewMilestone"
- Error message includes valid commands list

sanitizeArguments tests:

- Returns sanitized object for valid args
- Throws for empty value
- Throws for value exceeding 500 chars
- Removes shell metacharacters: ; & | ` $ ( )
- Trims whitespace from values

NOTE: validator.js imports @actions/core for logging. The global mock in test/setup.js
already provides vi.fn() for core.info, so no additional mocking needed in this file.
If you need to verify core.info was called, import and use vi.mocked():

```javascript
import * as core from "@actions/core";
// In test:
expect(vi.mocked(core.info)).toHaveBeenCalledWith(
  expect.stringContaining("..."),
);
```

  </action>
  <verify>Run `npm test -- src/lib/parser.test.js src/lib/validator.test.js --run` - all tests pass</verify>
  <done>parser.js and validator.js have 90%+ coverage with edge cases tested</done>
</task>

<task type="auto">
  <name>Task 2: Create formatter.js and branches.js tests</name>
  <files>src/errors/formatter.test.js, src/git/branches.test.js</files>
  <action>
  **formatter.test.js** - Test error and success formatters:

formatErrorComment tests:

- Includes error message in output
- Includes workflow URL link
- Includes stack trace in details section
- Handles error without stack trace gracefully
- Output is valid markdown (has ##, <details>)

formatSuccessComment tests:

- Includes summary in output
- Includes workflow URL
- Includes files table when filesCreated provided
- Includes decisions list when decisions provided
- Handles missing optional fields gracefully

NOTE: formatter.js imports getWorkflowRunUrl from github.js. Mock the import:

```javascript
vi.mock("../lib/github.js", () => ({
  getWorkflowRunUrl: vi.fn(() => "https://example.com/actions/runs/123"),
}));
```

**branches.test.js** - Test slugify function only (git operations tested in Plan 04):

slugify tests:

- Converts to lowercase
- Replaces spaces with hyphens
- Replaces special characters with hyphens
- Removes leading/trailing hyphens
- Limits length to 50 characters
- Returns empty string for null/undefined
- Handles consecutive special characters (no double hyphens)

NOTE: Only test slugify - the git operation functions (createMilestoneBranch, createPhaseBranch, branchExists) require child_process mocking, handled in Plan 04.
</action>
<verify>Run `npm test -- src/errors/formatter.test.js src/git/branches.test.js --run` - all tests pass</verify>
<done>formatter.js formatters tested, branches.js slugify tested with edge cases</done>
</task>

<task type="auto">
  <name>Task 3: Create prompts.js and auth/errors.js tests</name>
  <files>src/llm/prompts.test.js, src/auth/errors.test.js</files>
  <action>
  **prompts.test.js** - Test prompt template:

createMilestonePrompt tests:

- Returns string containing milestone specification
- Includes JSON representation of args
- Contains expected instruction sections
- Handles empty args object
- Handles args with special characters (escaped properly in JSON)

**auth/errors.test.js** - Test error class and formatter:

AuthorizationError tests:

- Is instance of Error
- Has name "AuthorizationError"
- Has isAuthorizationError property set to true
- Stores technical message
- Stores userMessage separately

formatAuthorizationError tests:

- Includes username in output
- Includes repository name
- Includes workflow URL
- Contains "Permission Denied" header
- Lists required permissions (Write, Maintain, Admin)
- Contains instructions for requesting access
  </action>
  <verify>Run `npm test -- src/llm/prompts.test.js src/auth/errors.test.js --run` - all tests pass</verify>
  <done>All pure logic modules have comprehensive test coverage</done>
  </task>

</tasks>

<verification>
1. `npm test -- --run` runs all tests without errors
2. `npm run test:coverage` shows:
   - src/lib/parser.js: >90% coverage
   - src/lib/validator.js: >90% coverage
   - src/errors/formatter.js: >90% coverage
   - src/git/branches.js slugify: 100% coverage
   - src/llm/prompts.js: >90% coverage
   - src/auth/errors.js: >90% coverage
3. All edge cases documented in test descriptions
</verification>

<success_criteria>

- 6 test files created, colocated with source modules
- Pure functions tested without any external mocking (except @actions/core logging)
- Edge cases covered: empty inputs, special characters, length limits
- All tests pass on `npm test -- --run`
- Coverage meets 90%+ threshold for pure logic modules
  </success_criteria>

<output>
After completion, create `.planning/phases/10-test-for-each-service-method-feature-and-flow/10-02-SUMMARY.md`
</output>
