---
phase: 10-test-infrastructure
plan: 06
type: execute
wave: 3
depends_on: ["10-02", "10-03", "10-04"]
files_modified:
  - src/index.test.js
autonomous: true

must_haves:
  truths:
    - "Entry point command dispatch tested"
    - "All command flows verified (new-milestone, plan-phase, execute-phase)"
    - "Authorization check happens before command execution"
    - "Error handling wraps entire execution"
  artifacts:
    - path: "src/index.test.js"
      provides: "Integration tests for main entry point and command dispatch"
      min_lines: 150
  key_links:
    - from: "src/index.test.js"
      to: "withErrorHandling"
      via: "wrapper function"
      pattern: "withErrorHandling"
---

<objective>
Create integration tests for the main entry point (src/index.js).

Purpose: Verify the complete command dispatch flow from GitHub Action input through authorization check to command execution and response posting.

Output: Comprehensive integration test file covering all supported commands and error scenarios.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-test-for-each-service-method-feature-and-flow/10-RESEARCH.md
@.planning/phases/10-test-for-each-service-method-feature-and-flow/10-02-SUMMARY.md
@.planning/phases/10-test-for-each-service-method-feature-and-flow/10-03-SUMMARY.md
@.planning/phases/10-test-for-each-service-method-feature-and-flow/10-04-SUMMARY.md
@src/index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create index.test.js with comprehensive mocking</name>
  <files>src/index.test.js</files>
  <action>
  Create integration test file that tests index.js as a module. Since index.js executes code at module load time, we need to handle this carefully.

  **Mock setup:**

  ```javascript
  import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

  // Mock @actions/core FIRST (before any imports that use it)
  vi.mock('@actions/core', () => ({
    getInput: vi.fn(),
    setOutput: vi.fn(),
    setFailed: vi.fn(),
    info: vi.fn(),
    debug: vi.fn(),
    warning: vi.fn(),
    error: vi.fn()
  }));

  // Mock @actions/github
  vi.mock('@actions/github', () => ({
    context: {
      repo: { owner: 'test-owner', repo: 'test-repo' },
      issue: { number: 123 },
      payload: {
        sender: { login: 'test-user' },
        comment: { id: 456 }
      },
      token: 'mock-token',
      server_url: 'https://github.com',
      repository: 'test-owner/test-repo',
      run_id: '12345',
      run_attempt: '1'
    },
    getOctokit: vi.fn(() => mockOctokit)
  }));

  // Mock all module dependencies
  vi.mock('./auth/index.js', () => ({
    checkAuthorization: vi.fn(),
    formatAuthorizationError: vi.fn()
  }));

  vi.mock('./lib/github.js', () => ({
    octokit: mockOctokit,
    postComment: vi.fn(),
    getWorkflowRunUrl: vi.fn(() => 'https://example.com/run/123')
  }));

  vi.mock('./lib/parser.js', () => ({
    parseComment: vi.fn(),
    parseArguments: vi.fn()
  }));

  vi.mock('./lib/validator.js', () => ({
    validateCommand: vi.fn(),
    sanitizeArguments: vi.fn()
  }));

  vi.mock('./lib/config.js', () => ({
    loadConfig: vi.fn()
  }));

  vi.mock('./errors/formatter.js', () => ({
    formatErrorComment: vi.fn(),
    formatSuccessComment: vi.fn()
  }));

  vi.mock('./errors/handler.js', () => ({
    withErrorHandling: vi.fn()
  }));

  vi.mock('./git/git.js', () => ({
    runGitCommand: vi.fn(),
    createAndSwitchBranch: vi.fn(),
    switchBranch: vi.fn(),
    configureGitIdentity: vi.fn()
  }));

  vi.mock('./git/branches.js', () => ({
    createMilestoneBranch: vi.fn(),
    createPhaseBranch: vi.fn(),
    slugify: vi.fn(),
    branchExists: vi.fn()
  }));

  vi.mock('./milestone/index.js', () => ({
    executeMilestoneWorkflow: vi.fn(),
    parseMilestoneNumber: vi.fn()
  }));

  vi.mock('./milestone/planning-docs.js', () => ({
    createPlanningDocs: vi.fn(),
    generateProjectMarkdown: vi.fn(),
    generateStateMarkdown: vi.fn(),
    generateRoadmapMarkdown: vi.fn()
  }));

  vi.mock('./milestone/phase-planner.js', () => ({
    executePhaseWorkflow: vi.fn()
  }));

  vi.mock('./milestone/phase-executor.js', () => ({
    executePhaseExecutionWorkflow: vi.fn()
  }));
  ```

  **Note:** Since index.js executes immediately on import, we test by:
  1. Setting up mocks
  2. Configuring withErrorHandling to capture and execute the operation
  3. Verifying the operation behavior

  Alternative approach - extract testable functions:
  The entry point has inline execution that's hard to test. For this test, focus on verifying the mock wiring works and the logical flow is correct by examining what withErrorHandling receives.
  </action>
  <verify>Run `npm test -- src/index.test.js --run` - tests execute (may need adjustment based on module structure)</verify>
  <done>index.test.js created with comprehensive mock setup</done>
</task>

<task type="auto">
  <name>Task 2: Add command dispatch tests</name>
  <files>src/index.test.js</files>
  <action>
  Add test cases for each command flow. Since index.js executes at load time, test the withErrorHandling operation callback:

  ```javascript
  import * as core from '@actions/core';
  import { withErrorHandling } from './errors/handler.js';
  import { checkAuthorization } from './auth/index.js';
  import { parseComment, parseArguments } from './lib/parser.js';
  import { validateCommand, sanitizeArguments } from './lib/validator.js';
  import { executeMilestoneWorkflow } from './milestone/index.js';
  import { executePhaseWorkflow } from './milestone/phase-planner.js';
  import { executePhaseExecutionWorkflow } from './milestone/phase-executor.js';

  describe('index.js command dispatch', () => {
    let capturedOperation;

    beforeEach(() => {
      vi.clearAllMocks();

      // Capture the operation passed to withErrorHandling
      vi.mocked(withErrorHandling).mockImplementation(async (operation, context) => {
        capturedOperation = operation;
        return { success: true };
      });

      // Default mock implementations
      vi.mocked(core.getInput).mockImplementation((name) => {
        const inputs = {
          'issue-number': '123',
          'repo-owner': 'test-owner',
          'repo-name': 'test-repo',
          'comment-body': '@gsd-bot new-milestone'
        };
        return inputs[name] || '';
      });

      vi.mocked(checkAuthorization).mockResolvedValue({
        authorized: true,
        username: 'test-user',
        permission: 'write'
      });

      vi.mocked(parseComment).mockReturnValue({
        botMention: '@gsd-bot new-milestone',
        command: 'new-milestone',
        args: ''
      });

      vi.mocked(parseArguments).mockReturnValue({});
      vi.mocked(validateCommand).mockReturnValue(undefined);
      vi.mocked(sanitizeArguments).mockReturnValue({});
    });
  });
  ```

  **Test cases to add:**

  1. "returns commandFound: false when bot not mentioned"
     - parseComment returns null
     - Operation returns { commandFound: false }

  2. "returns authorized: false when user lacks permission"
     - checkAuthorization returns { authorized: false, reason: 'read only' }
     - Operation returns { authorized: false }

  3. "dispatches to executeMilestoneWorkflow for new-milestone"
     - parseComment returns command: 'new-milestone'
     - executeMilestoneWorkflow is called
     - Result includes milestone workflow output

  4. "dispatches to executePhaseWorkflow for plan-phase"
     - parseComment returns command: 'plan-phase', args: '7'
     - executePhaseWorkflow is called with args '7'

  5. "dispatches to executePhaseExecutionWorkflow for execute-phase"
     - parseComment returns command: 'execute-phase', args: '7'
     - executePhaseExecutionWorkflow is called with args '7'

  6. "validates command before execution"
     - validateCommand is called with parsed command

  7. "sanitizes arguments before passing to workflow"
     - sanitizeArguments is called with parsed args

  8. "configures git identity for commits"
     - configureGitIdentity is called with bot identity
  </action>
  <verify>Run `npm test -- src/index.test.js --run` - all command dispatch tests pass</verify>
  <done>Command dispatch logic tested for all three commands</done>
</task>

<task type="auto">
  <name>Task 3: Add error handling and output tests</name>
  <files>src/index.test.js</files>
  <action>
  Add tests for error scenarios and output setting:

  **Error handling tests:**

  1. "calls setFailed when withErrorHandling returns failure"
     - withErrorHandling returns { success: false, error: 'Test error' }
     - Verify error handling flow

  2. "posts authorization error for unauthorized users"
     - checkAuthorization returns { authorized: false }
     - formatAuthorizationError is called
     - postComment is called with error message

  3. "throws for unknown command"
     - validateCommand throws Error('Unknown command')
     - Error propagates through withErrorHandling

  **Output setting tests:**

  4. "sets command-found output to true when command found"
     - core.setOutput called with 'command-found', 'true'

  5. "sets command-found output to false when no bot mention"
     - parseComment returns null
     - core.setOutput called with 'command-found', 'false'

  6. "sets milestone-complete output for new-milestone"
     - executeMilestoneWorkflow returns { complete: true }
     - core.setOutput called with 'milestone-complete', true

  7. "sets phase-planned output for plan-phase"
     - executePhaseWorkflow returns { complete: true, phaseNumber: 7 }
     - core.setOutput called with 'phase-planned', true

  8. "sets has-questions output for execute-phase"
     - executePhaseExecutionWorkflow returns { hasQuestions: true }
     - core.setOutput called with 'has-questions', true

  **Integration verification:**

  9. "logs module loading confirmation"
     - console.log is called with "Modules loaded:"

  10. "extracts context from GitHub action inputs"
      - core.getInput called for issue-number, repo-owner, repo-name, comment-body
  </action>
  <verify>Run `npm test -- src/index.test.js --run --coverage` - all tests pass with coverage</verify>
  <done>Entry point fully tested with error handling and outputs</done>
</task>

</tasks>

<verification>
1. `npm test -- src/index.test.js --run` passes all tests
2. All three commands dispatched correctly
3. Authorization check verified to happen before command execution
4. Error handling wraps entire execution
5. Outputs set correctly for each command type
6. Coverage shows >70% for index.js (some code may be unreachable due to module execution pattern)
</verification>

<success_criteria>
- src/index.test.js created with comprehensive mocking
- All command dispatch paths tested (new-milestone, plan-phase, execute-phase)
- Authorization flow verified
- Error handling tested
- GitHub Action outputs verified
- All tests pass on `npm test -- src/index.test.js --run`
</success_criteria>

<output>
After completion, create `.planning/phases/10-test-for-each-service-method-feature-and-flow/10-06-SUMMARY.md`
</output>
