---
phase: 05-milestone-creation-workflow
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/milestone/requirements.js
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Requirements questions are posted as markdown comments"
    - "User answers are parsed from new comments since last workflow run"
    - "Bot comments are filtered out (only human responses processed)"
  artifacts:
    - path: "src/milestone/requirements.js"
      provides: "Requirements gathering logic"
      exports: ["getNewComments", "parseUserAnswers", "formatRequirementsQuestions", "parseAnswersFromResponse", "DEFAULT_QUESTIONS"]
  key_links:
    - from: "src/milestone/requirements.js"
      to: "src/lib/github.js"
      via: "octokit.paginate for comments"
      pattern: "octokit\\.paginate.*listComments"
---

<objective>
Create the requirements gathering module that posts questions, reads user answers from comments, and supports multi-turn interaction across workflow runs.

Purpose: Enable interactive requirements gathering where the agent asks questions and the user responds via GitHub comments.
Output: src/milestone/requirements.js with comment fetching, answer parsing, and question formatting
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/dejan/00-code/00-ai-agents-skills-plugins/agent/.planning/phases/05-milestone-creation-workflow/05-RESEARCH.md
@/Users/dejan/00-code/00-ai-agents-skills-plugins/agent/src/lib/github.js
</context>

<tasks>

<task type="auto">
  <name>Create src/milestone/requirements.js module</name>
  <files>src/milestone/requirements.js</files>
  <action>
Create the requirements gathering module with the following structure:

1. Import required modules:
   - * as github from "@actions/github"
   - * as core from "@actions/core"

2. Define DEFAULT_QUESTIONS array with 4 questions:
   - id: "scope", question: "What is the primary goal of this milestone?", required: true
   - id: "features", question: "What are the key features or deliverables?", required: true
   - id: "constraints", question: "Are there any technical constraints or requirements?", required: false
   - id: "timeline", question: "What is the expected timeline?", required: false

3. Export getNewComments(owner, repo, issueNumber, lastProcessedId):
   - Get octokit instance with token from core.getInput("token")
   - Use octokit.paginate to fetch ALL comments for the issue
   - Filter to comments with id > lastProcessedId (newer only)
   - Sort by id ascending (oldest first)
   - Skip bot comments (user.type === "Bot" or user.login === "github-actions[bot]")

4. Export parseUserAnswers(comments):
   - Filter out bot comments
   - Return array of { commentId, user, body, timestamp } objects

5. Export formatRequirementsQuestions(questions, existingAnswers):
   - Format questions as markdown
   - Show status icons: white_check_mark for answered, hourglass for pending
   - Include existing answers in blockquotes
   - Add instruction for user to reply

6. Export parseAnswersFromResponse(body, questions):
   - Parse user freeform response into answers keyed by question ID
   - Support Q: prefix patterns and paragraph-order fallback

Reference Pattern 2 and Pattern 3 in 05-RESEARCH.md for exact implementation.
  </action>
  <verify>
node --input-type=module -e "
import { getNewComments, parseUserAnswers, formatRequirementsQuestions, parseAnswersFromResponse, DEFAULT_QUESTIONS } from './src/milestone/requirements.js';

console.log('All exports available:', {
  getNewComments: typeof getNewComments === 'function',
  parseUserAnswers: typeof parseUserAnswers === 'function',
  formatRequirementsQuestions: typeof formatRequirementsQuestions === 'function',
  parseAnswersFromResponse: typeof parseAnswersFromResponse === 'function',
  DEFAULT_QUESTIONS: Array.isArray(DEFAULT_QUESTIONS)
});

// Test question formatting
const existingAnswers = { scope: 'Build authentication' };
const formatted = formatRequirementsQuestions(DEFAULT_QUESTIONS, existingAnswers);
console.log('Questions formatted:', formatted.includes('white_check_mark') && formatted.includes('hourglass'));

// Test answer parsing
const userResponse = 'Q: Build auth system\nQ: Login, logout, password reset\nQ: Use existing DB';
const parsed = parseAnswersFromResponse(userResponse, DEFAULT_QUESTIONS);
console.log('Answers parsed:', Object.keys(parsed).length > 0);
"
</verify>
  <done>
src/milestone/requirements.js exists with all 5 exports working correctly, and test output confirms question formatting and answer parsing function
</done>
</task>

<task type="auto">
  <name>Test bot comment filtering logic</name>
  <files>src/milestone/requirements.js</files>
  <action>
Add and test the bot comment filtering logic:

1. Create test data simulating GitHub comment objects with:
   - Human user comments
   - Bot comments (github-actions[bot])
   - Bot comments (user.type === "Bot")

2. Test parseUserAnswers to verify:
   - Human comments are included
   - Bot comments are excluded
   - Returned objects have correct structure (commentId, user, body, timestamp)

3. Verify getNewComments would correctly filter by lastProcessedId
  </action>
  <verify>
node --input-type=module -e "
import { parseUserAnswers } from './src/milestone/requirements.js';

const mockComments = [
  { id: 100, user: { type: 'User', login: 'alice' }, body: 'Answer to question 1', created_at: '2026-01-22T10:00:00Z' },
  { id: 101, user: { type: 'Bot', login: 'github-actions[bot]' }, body: 'I posted requirements questions', created_at: '2026-01-22T10:01:00Z' },
  { id: 102, user: { type: 'User', login: 'bob' }, body: 'Answer to question 2', created_at: '2026-01-22T10:02:00Z' },
  { id: 103, user: { type: 'Bot', login: 'dependabot[bot]' }, body: 'Security update', created_at: '2026-01-22T10:03:00Z' },
];

const answers = parseUserAnswers(mockComments);
console.log('Human answers extracted:', answers.length);
console.log('Bot comments filtered:', answers.every(a => a.user === 'alice' || a.user === 'bob'));
console.log('Answer structure correct:', answers.every(a => a.commentId && a.user && a.body));

// Verify the correct comments were captured
const commentIds = answers.map(a => a.commentId);
console.log('Correct IDs captured (100, 102):', JSON.stringify(commentIds) === '[100,102]');
"
</verify>
  <done>
parseUserAnswers correctly filters out bot comments and returns only human responses with proper structure
</done>
</task>

</tasks>

<verification>
1. Module imports without errors in Node.js
2. DEFAULT_QUESTIONS has 4 questions with correct structure
3. formatRequirementsQuestions produces markdown with status icons
4. parseUserAnswers filters bot comments correctly
5. parseAnswersFromResponse extracts answers from user response
6. getNewComments signature accepts required parameters
</verification>

<success_criteria>
- src/milestone/requirements.js exports all required functions
- Bot comments are correctly filtered (github-actions[bot] and user.type === "Bot")
- Questions can be formatted with status indicators
- User answers can be parsed from comment body text
</success_criteria>

<output>
After completion, create `.planning/phases/05-milestone-creation-workflow/05-02-SUMMARY.md`
</output>
