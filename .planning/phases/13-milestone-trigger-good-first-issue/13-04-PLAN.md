---
phase: 13-milestone-trigger-good-first-issue
plan: 04
type: execute
wave: 2
depends_on: ["13-03"]
files_modified:
  - src/milestone/label-trigger.js
  - src/milestone/label-trigger.test.js
  - src/lib/github.js
autonomous: true

must_haves:
  truths:
    - "After GSD completes, issue is updated with milestone info"
    - "Issue body contains version, title, and phase links"
    - "Original issue content is preserved above the milestone info"
  artifacts:
    - path: "src/milestone/label-trigger.js"
      provides: "Complete label trigger workflow with issue update"
      exports: ["executeLabelTriggerWorkflow"]
    - path: "src/lib/github.js"
      provides: "updateIssueBody function"
      exports: ["updateIssueBody"]
  key_links:
    - from: "src/milestone/label-trigger.js"
      to: "src/lib/planning-parser.js"
      via: "import parseMilestoneMetadata"
      pattern: "import.*parseMilestoneMetadata"
    - from: "src/milestone/label-trigger.js"
      to: "src/lib/github.js"
      via: "import updateIssueBody"
      pattern: "import.*updateIssueBody"
---

<objective>
Complete the label trigger workflow by parsing GSD output and updating the triggering issue with milestone information.

Purpose: Close the feedback loop - user sees milestone info directly on the issue they labeled
Output: Updated label-trigger.js with post-GSD parsing and issue update
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Modules from prior plans
@src/milestone/label-trigger.js (from 13-01)
@src/lib/planning-parser.js (from 13-03)
@src/lib/github.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add updateIssueBody to github.js</name>
  <files>src/lib/github.js</files>
  <action>
Add new function to src/lib/github.js:

```javascript
/**
 * Update issue body with new content
 * @param {string} owner - Repository owner
 * @param {string} repo - Repository name
 * @param {number} issueNumber - Issue number
 * @param {string} body - New body content
 * @returns {Promise<void>}
 */
export async function updateIssueBody(owner, repo, issueNumber, body) {
  await octokit.rest.issues.update({
    owner,
    repo,
    issue_number: issueNumber,
    body,
  });
}
```

This is a simple wrapper around octokit.rest.issues.update for updating issue body.
  </action>
  <verify>
grep "updateIssueBody" src/lib/github.js
Function is exported
  </verify>
  <done>
updateIssueBody function added to github.js
Uses existing octokit instance
  </done>
</task>

<task type="auto">
  <name>Task 2: Complete label-trigger.js with issue update</name>
  <files>src/milestone/label-trigger.js</files>
  <action>
Update src/milestone/label-trigger.js to add post-GSD parsing and issue update:

1. Add imports:
```javascript
import { parseMilestoneMetadata } from '../lib/planning-parser.js';
import { updateIssueBody, postComment } from '../lib/github.js';
```

2. After CCR execution succeeds, add parsing and update:
```javascript
// After successful GSD execution...

// Step 4: Parse milestone metadata from generated files
const metadata = await parseMilestoneMetadata();

if (!metadata || !metadata.title) {
  core.warning('Could not parse milestone metadata, skipping issue update');
  // Still return success - GSD completed
  return { complete: true, phase: 'gsd-complete-no-metadata' };
}

// Step 5: Format milestone info section
const phaseList = metadata.phases.length > 0
  ? metadata.phases.map(p =>
      `- [ ] Phase ${p.number}: ${p.name} (${p.status})`
    ).join('\n')
  : '- No phases defined yet';

const milestoneSection = `

---

## Milestone Created: ${metadata.title} ${metadata.version}

${metadata.coreValue ? `**Core Value:** ${metadata.coreValue}` : ''}

### Phases

${phaseList}

---
*Created by GSD Bot via "good first issue" label*
`;

// Step 6: Update issue body (append milestone info to original)
const originalBody = issueBody || '';
const updatedBody = originalBody + milestoneSection;

await updateIssueBody(owner, repo, issueNumber, updatedBody);
core.info(`Updated issue #${issueNumber} with milestone info`);

// Step 7: Post success comment
await postComment(
  owner,
  repo,
  issueNumber,
  `## Milestone Created

**${metadata.title}** (${metadata.version}) has been created from this issue.

${metadata.phases.length} phase(s) defined. See the updated issue body for details.

Next steps:
- Review planning docs in \`.planning/\`
- Use \`@gsd-bot plan-phase N\` to plan each phase
- Use \`@gsd-bot execute-phase N\` to implement`
);

return {
  complete: true,
  phase: 'milestone-created',
  title: metadata.title,
  version: metadata.version,
  phaseCount: metadata.phases.length,
};
```

3. Handle errors gracefully:
- If metadata parsing fails: log warning, return success (GSD completed)
- If issue update fails: log error, don't fail workflow (core work done)
  </action>
  <verify>
npm test -- src/milestone/label-trigger.test.js
All tests pass
  </verify>
  <done>
label-trigger.js parses metadata after GSD
Issue body updated with milestone section
Success comment posted
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for issue update flow</name>
  <files>src/milestone/label-trigger.test.js</files>
  <action>
Add tests for the complete workflow including issue update:

```javascript
describe('executeLabelTriggerWorkflow - issue update', () => {
  it('should update issue with milestone info after GSD completes', async () => {
    // Mock successful CCR execution
    execAsync.mockResolvedValue({ stdout: 'success' });
    fs.readFile.mockImplementation((path) => {
      if (path.includes('REQUIREMENTS')) {
        return '# Requirements: Test v1.0\n\n**Core Value:** Testing.';
      }
      if (path.includes('ROADMAP')) {
        return '### Phase 1: Setup\n\n**Status:** Not started';
      }
      return '';
    });

    const result = await executeLabelTriggerWorkflow({
      owner: 'test',
      repo: 'repo',
      issueNumber: 42,
      issueTitle: 'Build login',
      issueBody: 'Need authentication',
    });

    expect(result.complete).toBe(true);
    expect(result.title).toBe('Test');
    expect(updateIssueBody).toHaveBeenCalledWith(
      'test', 'repo', 42,
      expect.stringContaining('Milestone Created: Test v1.0')
    );
  });

  it('should preserve original issue body', async () => {
    // ... setup mocks ...

    await executeLabelTriggerWorkflow({
      // ...
      issueBody: 'Original content here',
    });

    expect(updateIssueBody).toHaveBeenCalledWith(
      expect.anything(),
      expect.anything(),
      expect.anything(),
      expect.stringContaining('Original content here')
    );
  });

  it('should handle metadata parsing failure gracefully', async () => {
    execAsync.mockResolvedValue({ stdout: 'success' });
    fs.readFile.mockRejectedValue(new Error('Parse error'));

    const result = await executeLabelTriggerWorkflow({ /* ... */ });

    expect(result.complete).toBe(true); // Still succeeds
    expect(updateIssueBody).not.toHaveBeenCalled();
  });
});
```
  </action>
  <verify>
npm test -- src/milestone/label-trigger.test.js
All tests pass including new issue update tests
  </verify>
  <done>
Tests cover successful issue update
Tests cover original body preservation
Tests cover graceful failure handling
  </done>
</task>

</tasks>

<verification>
1. npm test - all tests pass
2. npm run build - bundle compiles
3. Full workflow: label -> GSD -> parse -> update issue
</verification>

<success_criteria>
- updateIssueBody added to github.js
- label-trigger.js parses metadata after GSD success
- Issue body updated with milestone info (appended, not replaced)
- Success comment posted with next steps
- Graceful handling of parse/update failures
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-milestone-trigger-good-first-issue/13-04-SUMMARY.md`
</output>
