---
phase: 13-milestone-trigger-good-first-issue
plan: 03
type: execute
wave: 2
depends_on: ["13-01", "13-02"]
files_modified:
  - src/lib/planning-parser.js
  - src/lib/planning-parser.test.js
autonomous: true

must_haves:
  truths:
    - "Can parse milestone title and version from REQUIREMENTS.md"
    - "Can parse phase numbers and titles from ROADMAP.md"
    - "Returns structured data suitable for issue update"
  artifacts:
    - path: "src/lib/planning-parser.js"
      provides: "Parsers for GSD planning artifact files"
      exports: ["parseRequirements", "parseRoadmap"]
  key_links:
    - from: "src/lib/planning-parser.js"
      to: ".planning/REQUIREMENTS.md"
      via: "fs.readFile"
      pattern: "readFile.*REQUIREMENTS"
    - from: "src/lib/planning-parser.js"
      to: ".planning/ROADMAP.md"
      via: "fs.readFile"
      pattern: "readFile.*ROADMAP"
---

<objective>
Create parsing utilities to extract milestone metadata from GSD planning artifacts after new-milestone completes.

Purpose: Extract structured data (title, version, phases) for updating the triggering issue
Output: planning-parser.js module with parseRequirements and parseRoadmap functions
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Example files to parse (this repo's own planning docs)
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create planning-parser.js module</name>
  <files>src/lib/planning-parser.js</files>
  <action>
Create src/lib/planning-parser.js with two parsers:

```javascript
import fs from 'fs/promises';
import * as core from '@actions/core';

/**
 * Parse REQUIREMENTS.md to extract milestone metadata
 * @returns {Promise<{title: string, version: string, coreValue: string} | null>}
 */
export async function parseRequirements() {
  try {
    const content = await fs.readFile('.planning/REQUIREMENTS.md', 'utf-8');

    // Extract title from first H1: # Requirements: GSD for GitHub v1.1
    // Pattern: # Requirements: {title} v{version}
    const titleMatch = content.match(/^#\s+Requirements:\s+(.+?)\s+v(\d+\.\d+)/m);

    // Extract Core Value paragraph
    const coreValueMatch = content.match(/\*\*Core Value:\*\*\s+(.+?)(?:\n\n|\n##)/s);

    if (!titleMatch) {
      core.warning('Could not parse title from REQUIREMENTS.md');
      return null;
    }

    return {
      title: titleMatch[1].trim(),
      version: `v${titleMatch[2]}`,
      coreValue: coreValueMatch ? coreValueMatch[1].trim() : null,
    };
  } catch (error) {
    if (error.code === 'ENOENT') {
      core.info('REQUIREMENTS.md not found (no active milestone)');
      return null;
    }
    throw error;
  }
}

/**
 * Parse ROADMAP.md to extract phase information
 * @returns {Promise<{phases: Array<{number: number, name: string, status: string}>}>}
 */
export async function parseRoadmap() {
  try {
    const content = await fs.readFile('.planning/ROADMAP.md', 'utf-8');

    const phases = [];

    // Match phase headers: ### Phase N: Phase Name
    // Also match status: **Status:** Complete or **Status:** Not started
    const phasePattern = /###\s+Phase\s+(\d+(?:\.\d+)?):?\s+(.+?)(?:\n|$)/g;
    let match;

    while ((match = phasePattern.exec(content)) !== null) {
      const phaseNumber = match[1];
      const phaseName = match[2].trim();

      // Find status for this phase (appears after the header)
      const afterPhase = content.slice(match.index);
      const statusMatch = afterPhase.match(/\*\*Status:\*\*\s+(Complete|Not started|In progress)/i);
      const status = statusMatch ? statusMatch[1].toLowerCase() : 'not started';

      phases.push({
        number: phaseNumber,
        name: phaseName,
        status: status.replace(' ', '-'), // "not started" -> "not-started"
      });
    }

    return { phases };
  } catch (error) {
    if (error.code === 'ENOENT') {
      core.info('ROADMAP.md not found');
      return { phases: [] };
    }
    throw error;
  }
}

/**
 * Parse both files and return combined milestone metadata
 * @returns {Promise<{title: string, version: string, coreValue: string, phases: Array}>}
 */
export async function parseMilestoneMetadata() {
  const [requirements, roadmap] = await Promise.all([
    parseRequirements(),
    parseRoadmap(),
  ]);

  return {
    ...requirements,
    phases: roadmap.phases,
  };
}
```
  </action>
  <verify>
File exists at src/lib/planning-parser.js
Exports parseRequirements, parseRoadmap, parseMilestoneMetadata
  </verify>
  <done>
planning-parser.js module created with all three exports
Handles file-not-found gracefully (returns null/empty)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create tests for planning-parser.js</name>
  <files>src/lib/planning-parser.test.js</files>
  <action>
Create comprehensive tests for the parser module:

```javascript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import fs from 'fs/promises';
import { parseRequirements, parseRoadmap, parseMilestoneMetadata } from './planning-parser.js';

vi.mock('fs/promises');
vi.mock('@actions/core', () => ({
  info: vi.fn(),
  warning: vi.fn(),
}));

describe('parseRequirements', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should parse title and version from REQUIREMENTS.md', async () => {
    fs.readFile.mockResolvedValue(`# Requirements: GSD for GitHub v1.1

**Defined:** 2026-01-22
**Milestone:** v1.1 - Plan & Execute Commands
**Core Value:** Enable autonomous AI-driven development.

## Requirements
...`);

    const result = await parseRequirements();

    expect(result.title).toBe('GSD for GitHub');
    expect(result.version).toBe('v1.1');
    expect(result.coreValue).toContain('autonomous AI-driven');
  });

  it('should return null if REQUIREMENTS.md not found', async () => {
    const error = new Error('ENOENT');
    error.code = 'ENOENT';
    fs.readFile.mockRejectedValue(error);

    const result = await parseRequirements();
    expect(result).toBeNull();
  });

  it('should return null if title cannot be parsed', async () => {
    fs.readFile.mockResolvedValue('# Some other format');

    const result = await parseRequirements();
    expect(result).toBeNull();
  });
});

describe('parseRoadmap', () => {
  it('should parse phases from ROADMAP.md', async () => {
    fs.readFile.mockResolvedValue(`# Roadmap

### Phase 7: Phase Planning Command

**Status:** Complete

### Phase 8: Phase Execution Command

**Status:** Not started
`);

    const result = await parseRoadmap();

    expect(result.phases).toHaveLength(2);
    expect(result.phases[0]).toEqual({
      number: '7',
      name: 'Phase Planning Command',
      status: 'complete',
    });
    expect(result.phases[1]).toEqual({
      number: '8',
      name: 'Phase Execution Command',
      status: 'not-started',
    });
  });

  it('should handle phases with decimal numbers (8.1)', async () => {
    fs.readFile.mockResolvedValue(`### Phase 8.1: GitHub Projects

**Status:** Complete`);

    const result = await parseRoadmap();
    expect(result.phases[0].number).toBe('8.1');
  });

  it('should return empty phases if ROADMAP.md not found', async () => {
    const error = new Error('ENOENT');
    error.code = 'ENOENT';
    fs.readFile.mockRejectedValue(error);

    const result = await parseRoadmap();
    expect(result.phases).toEqual([]);
  });
});

describe('parseMilestoneMetadata', () => {
  it('should combine requirements and roadmap data', async () => {
    fs.readFile
      .mockResolvedValueOnce('# Requirements: Test Project v2.0\n\n**Core Value:** Testing.')
      .mockResolvedValueOnce('### Phase 1: Setup\n\n**Status:** Complete');

    const result = await parseMilestoneMetadata();

    expect(result.title).toBe('Test Project');
    expect(result.version).toBe('v2.0');
    expect(result.phases).toHaveLength(1);
  });
});
```
  </action>
  <verify>
npm test -- src/lib/planning-parser.test.js
All tests pass
  </verify>
  <done>
Tests cover title/version parsing, phase parsing, file-not-found handling
Tests for decimal phase numbers (8.1)
Tests for combined metadata parsing
  </done>
</task>

</tasks>

<verification>
1. npm test -- src/lib/planning-parser.test.js - all tests pass
2. Module exports all three functions
3. Parsers handle edge cases (missing files, bad format)
</verification>

<success_criteria>
- parseRequirements extracts title, version, coreValue from REQUIREMENTS.md
- parseRoadmap extracts phase number, name, status from ROADMAP.md
- parseMilestoneMetadata combines both for easy consumption
- All edge cases handled (ENOENT, parse failures)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-milestone-trigger-good-first-issue/13-03-SUMMARY.md`
</output>
